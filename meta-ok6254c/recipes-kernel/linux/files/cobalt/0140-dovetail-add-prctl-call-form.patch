From 61d19212d2e0121b52d50ac013d6f7efdcb154c3 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 5 Sep 2021 17:23:22 +0200
Subject: [PATCH 140/179] dovetail: add prctl() call form

The syscall form used for issuing requests to the companion core is
based on ORing __OOB_SYSCALL_BIT to the syscall register for tagging
an out-of-band syscall, which is outside of the valid in-band range
for syscall numbers.

Unfortunately, this method has a major drawback: tools like Valgrind
which track system calls issued by applications may choke on
out-of-band system calls since these do not belong to the common set
it recognizes. Although adding syscall wrappers to Valgrind might be a
solution, this would not be the most practical one for dual kernel
syscall interfaces. The most practical approach would be to piggyback
on an existing system call which Valgrind (and others) already
recognizes.

To this end, we provide another option for issuing out-of-band
syscalls to the companion core, based on the prctl(2) call. When
caught on kernel entry, this request is unconditionally routed to the
core for inspection, along with any syscall which bears the
__OOB_SYSCALL_BIT tag as previously.

According to this scheme, the core should figure out whether it should
handle the current prctl() request, or leave it to the in-band kernel
(i.e. propagation status set to zero). To fit in the prctl()
signature, the core would typically use the prctl() @option argument
to encode its own syscall number, which would leave enough room for up
to 4 arguments to the corresponding request.

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 kernel/dovetail.c | 28 +++++++++++++++++++++-------
 1 file changed, 21 insertions(+), 7 deletions(-)

diff --git a/kernel/dovetail.c b/kernel/dovetail.c
index 13c140160..794e3998d 100644
--- a/kernel/dovetail.c
+++ b/kernel/dovetail.c
@@ -72,7 +72,7 @@ void __weak handle_oob_syscall(struct pt_regs *regs)
 int __weak handle_pipelined_syscall(struct irq_stage *stage,
 				    struct pt_regs *regs)
 {
-	return 0;
+	return 0;	/* i.e. propagate to in-band handler. */
 }
 
 void __weak handle_oob_mayday(struct pt_regs *regs)
@@ -166,6 +166,19 @@ int __pipeline_syscall(struct pt_regs *regs)
 	return ret;
 }
 
+static inline bool maybe_oob_syscall(unsigned int nr, struct pt_regs *regs)
+{
+	/*
+	 * Check whether the companion core might be interested in
+	 * @nr. Hand the request to the core if __OOB_SYSCALL_BIT is
+	 * set in @nr, or this is a prctl() request into which an oob
+	 * syscall might be folded. If the prctl() call ends up being
+	 * a regular in-band request, the core should tell us to
+	 * propagate it to the in-band handler eventually.
+	 */
+	return (nr & __OOB_SYSCALL_BIT) || nr == __NR_prctl;
+}
+
 int pipeline_syscall(unsigned int nr, struct pt_regs *regs)
 {
 	struct thread_info *ti = current_thread_info();
@@ -175,11 +188,12 @@ int pipeline_syscall(unsigned int nr, struct pt_regs *regs)
 	WARN_ON_ONCE(dovetail_debug() && hard_irqs_disabled());
 
 	/*
-	 * If __OOB_SYSCALL_BIT is set into the syscall number and we
-	 * are running out-of-band, pass the request directly to the
-	 * companion core by calling the oob syscall handler.
+	 * If the syscall signature belongs to the out-of-band syscall
+	 * set and we are running out-of-band, pass the request
+	 * directly to the companion core by calling the oob syscall
+	 * handler.
 	 *
-	 * Otherwise, if __OOB_SYSCALL_BIT is set or alternate
+	 * Otherwise, if this is an out-of-band syscall or alternate
 	 * scheduling is enabled for the caller, propagate the syscall
 	 * through the pipeline stages, so that:
 	 *
@@ -203,7 +217,7 @@ int pipeline_syscall(unsigned int nr, struct pt_regs *regs)
 	 * after exiting to user.
 	 */
 
-	if ((nr & __OOB_SYSCALL_BIT) && (local_flags & _TLF_OOB)) {
+	if ((local_flags & _TLF_OOB) && maybe_oob_syscall(nr, regs)) {
 		handle_oob_syscall(regs);
 		local_flags = READ_ONCE(ti_local_flags(ti));
 		if (local_flags & _TLF_OOB) {
@@ -216,7 +230,7 @@ int pipeline_syscall(unsigned int nr, struct pt_regs *regs)
 		}
 	}
 
-	if ((local_flags & _TLF_DOVETAIL) || (nr & __OOB_SYSCALL_BIT)) {
+	if ((local_flags & _TLF_DOVETAIL) || maybe_oob_syscall(nr, regs)) {
 		ret = __pipeline_syscall(regs);
 		local_flags = READ_ONCE(ti_local_flags(ti));
 		if (local_flags & _TLF_OOB)
-- 
2.38.1

