From 544f9347c1b8c50bfa055466bc133f8f3fbaeeed Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 20 Dec 2018 15:28:26 +0100
Subject: [PATCH 027/179] kasan: irq_pipeline: serialize reports from oob
 contexts

KASAN may detect issues in code running out-of-band, so we have to
serialize the report handler accordingly by turning the regular
spinlock into a hard lock.

This will trigger massive a latency spot when a report is emitted, but
since kernel sanity is at stake when this happens, such spike is not
the most urgent issue.

This also means that the KASAN report lock becomes a raw lock -
therefore cannot sleep with full preemption enabled.

Signed-off-by: Philippe Gerum <rpm@xenomai.org>
---
 mm/kasan/report.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index 00a53f135..a4e397405 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -78,7 +78,7 @@ static void print_error_description(struct kasan_access_info *info)
 		info->access_addr, current->comm, task_pid_nr(current));
 }
 
-static DEFINE_SPINLOCK(report_lock);
+static DEFINE_HARD_SPINLOCK(report_lock);
 
 static void start_report(unsigned long *flags)
 {
@@ -86,7 +86,7 @@ static void start_report(unsigned long *flags)
 	 * Make sure we don't end up in loop.
 	 */
 	kasan_disable_current();
-	spin_lock_irqsave(&report_lock, *flags);
+	raw_spin_lock_irqsave(&report_lock, *flags);
 	pr_err("==================================================================\n");
 }
 
@@ -94,7 +94,7 @@ static void end_report(unsigned long *flags)
 {
 	pr_err("==================================================================\n");
 	add_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);
-	spin_unlock_irqrestore(&report_lock, *flags);
+	raw_spin_unlock_irqrestore(&report_lock, *flags);
 	if (panic_on_warn && !test_bit(KASAN_BIT_MULTI_SHOT, &kasan_flags)) {
 		/*
 		 * This thread may hit another WARN() in the panic path.
-- 
2.38.1

